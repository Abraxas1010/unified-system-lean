import Mathlib.CategoryTheory.Sites.Sieves

import HeytingLean.Compiler.TensorLogic.Eval

/-!
# FactsAsSieves — TensorLogic facts as generated sieves

This bridge provides a small abstraction: if you can interpret (some) TensorLogic ground atoms as
arrows into an object `X` of a category `C`, then a finite fact database determines a **generated**
sieve on `X` by taking the closure of those arrows under precomposition.

The definition is intentionally parametric:

* `atomArrow` supplies the semantic interpretation `Atom ↦ (Y ⟶ X)`.
* Facts with weight `0.0` are ignored; any non-zero weight is treated as “present”.

This keeps the bridge usable for multiple downstream “knowledge-graph category” choices.
-/

namespace HeytingLean
namespace LoF
namespace Bridge

open CategoryTheory
open HeytingLean.Compiler.TensorLogic

universe v u

section

variable {C : Type u} [Category.{v} C]
variable {X : C}

/-- A presieve consisting exactly of the arrows named by the nonzero-weight atoms in `F`. -/
def factsPresieve (atomArrow : Atom → Σ Y : C, (Y ⟶ X)) (F : Facts) : Presieve X :=
  fun {Y} (f : Y ⟶ X) =>
    ∃ a : Atom, (Facts.get F a) ≠ 0.0 ∧ atomArrow a = ⟨Y, f⟩

/-- The sieve generated by the presieve of “observed” fact-arrows. -/
def factsSieve (atomArrow : Atom → Σ Y : C, (Y ⟶ X)) (F : Facts) : Sieve X :=
  Sieve.generate (factsPresieve (X := X) atomArrow F)

theorem factsPresieve_le_factsSieve (atomArrow : Atom → Σ Y : C, (Y ⟶ X)) (F : Facts) :
    factsPresieve (X := X) atomArrow F ≤ factsSieve (X := X) atomArrow F := by
  simpa [factsSieve] using (Sieve.le_generate (factsPresieve (X := X) atomArrow F))

theorem atomArrow_mem_factsSieve
    (atomArrow : Atom → Σ Y : C, (Y ⟶ X)) (F : Facts)
    (a : Atom) (h : (Facts.get F a) ≠ 0.0) :
    factsSieve (X := X) atomArrow F (atomArrow a).2 := by
  have hpre :
      factsPresieve (X := X) atomArrow F (atomArrow a).2 :=
    ⟨a, h, rfl⟩
  exact (factsPresieve_le_factsSieve (X := X) atomArrow F) _ hpre

end

end Bridge
end LoF
end HeytingLean

