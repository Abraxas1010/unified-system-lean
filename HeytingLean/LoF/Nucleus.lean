import Mathlib.Order.Nucleus
import Mathlib.Order.Sublocale
import HeytingLean.LoF.PrimaryAlgebra

open scoped Classical

namespace HeytingLean
namespace LoF

/-- `Reentry α` packages the re-entry operation as a nucleus on a primary algebra together with
the minimal pair of complementary fixed points generated by the primordial distinction. -/
structure Reentry (α : Type u) [PrimaryAlgebra α] where
  nucleus : Nucleus α
  primordial : α
  counter : α
  /-- Optional “support window” used by some classical fragments. This
      field is not relied on by the core Ωᴿ / Euler-boundary theory and
      may be ignored by models that do not need a distinguished support. -/
  support : α := ⊤
  primordial_mem : nucleus primordial = primordial
  counter_mem : nucleus counter = counter
  primordial_nonbot : ⊥ < primordial
  counter_nonbot : ⊥ < counter
  orthogonal : primordial ⊓ counter = ⊥
  /-- The primordial fixed point always lies inside the designated support window. -/
  primordial_in_support : primordial ≤ support
  /-- Reentry fixes bottom: the nucleus maps `⊥` to `⊥`. -/
  map_bot : nucleus (⊥ : α) = (⊥ : α)
  /-- Minimality of the primordial fixed point is expressed relative to
      a designated support window. In the most general setting we only
      require that `primordial` dominates any nontrivial fixed point
      that lies inside `support`; concrete models are free to strengthen
      this further. -/
  primordial_minimal :
    ∀ ⦃x : α⦄, nucleus x = x → ⊥ < x → x ≤ support → primordial ≤ x

namespace Reentry

variable {α : Type u} [PrimaryAlgebra α]

instance : CoeFun (Reentry α) (fun _ => α → α) where
  coe R := R.nucleus

@[simp] lemma coe_nucleus (R : Reentry α) : (R.nucleus : α → α) = R := rfl

/-- A reentry is idempotent: applying it twice yields the same result. -/
@[simp] lemma idempotent (R : Reentry α) (a : α) : R (R a) = R a :=
  R.nucleus.idempotent _

/-- Every point lies below its image under the reentry nucleus. -/
@[simp] lemma le_apply (R : Reentry α) (a : α) : a ≤ R a :=
  Nucleus.le_apply (n := R.nucleus) (x := a)

/-- Reentry distributes over infima because it is a nucleus. -/
@[simp] lemma map_inf (R : Reentry α) (a b : α) : R (a ⊓ b) = R a ⊓ R b :=
  Nucleus.map_inf (n := R.nucleus) (x := a) (y := b)

/-- Reentry applied to a supremum equals the supremum of already reentered terms. -/
lemma map_sup (R : Reentry α) (a b : α) :
    R (a ⊔ b) = R ((R a) ⊔ (R b)) := by
  classical
  simpa [Reentry.coe_nucleus] using
    (R.nucleus.toClosureOperator.closure_sup_closure (x := a) (y := b)).symm

/-- The result of reentering each argument joins below reentering the whole join. -/
lemma map_sup_le (R : Reentry α) (a b : α) :
    R a ⊔ R b ≤ R (a ⊔ b) := by
  classical
  exact R.nucleus.toClosureOperator.closure_sup_closure_le (x := a) (y := b)

/-- Reentry is monotone with respect to Heyting implication on the right input. -/
lemma map_himp_le (R : Reentry α) (a b : α) :
    R (a ⇨ b) ≤ a ⇨ R b := by
  simpa [Reentry.coe_nucleus] using
    R.nucleus.map_himp_le (x := a) (y := b)

/-- Once the right argument has been reentered, the implication stays fixed. -/
@[simp] lemma map_himp_apply (R : Reentry α) (a b : α) :
    R (a ⇨ R b) = a ⇨ R b := by
  simpa [Reentry.coe_nucleus] using
    R.nucleus.map_himp_apply (x := a) (y := b)

/-! ### Sup-closure convenience lemmas -/

/-- Closing just the left argument of a join is redundant before reentering. -/
@[simp] lemma map_sup_left_closed (R : Reentry α) (a b : α) :
    R (R a ⊔ b) = R (a ⊔ b) := by
  classical
  simpa [Reentry.coe_nucleus]
    using (R.nucleus.toClosureOperator.closure_sup_closure_left (x := a) (y := b))

/-- Closing just the right argument of a join is also redundant. -/
@[simp] lemma map_sup_right_closed (R : Reentry α) (a b : α) :
    R (a ⊔ R b) = R (a ⊔ b) := by
  classical
  simpa [Reentry.coe_nucleus]
    using (R.nucleus.toClosureOperator.closure_sup_closure_right (x := a) (y := b))


/-- The reentry of bottom is bottom: this follows from the `Reentry.map_bot` field. -/
@[simp] lemma map_bot_apply (R : Reentry α) : R (⊥ : α) = (⊥ : α) := by
  simpa [Reentry.coe_nucleus] using R.map_bot

/-- Reentry is a monotone operator on the primary algebra. -/
@[simp] lemma monotone (R : Reentry α) : Monotone R :=
  R.nucleus.monotone

/-- Fixed points of the nucleus viewed as the associated sublocale `Ω_R`. -/
abbrev Omega (R : Reentry α) : Type u := R.nucleus.toSublocale

@[simp] lemma primordial_apply (R : Reentry α) :
    R R.primordial = R.primordial :=
  R.primordial_mem

@[simp] lemma counter_apply (R : Reentry α) :
    R R.counter = R.counter :=
  R.counter_mem

lemma primordial_le_of_fixed (R : Reentry α) {x : α}
    (hx_fix : R x = x) (hx_pos : ⊥ < x) (hx_support : x ≤ R.support) :
    R.primordial ≤ x :=
  R.primordial_minimal hx_fix hx_pos hx_support

namespace Omega

variable (R : Reentry α)

/-- Build an element of the fixed-point sublocale from an ambient element and a fixpoint proof. -/
def mk (a : α) (h : R a = a) :
    R.Omega := ⟨a, ⟨a, h⟩⟩

@[simp] lemma coe_mk (a : α) (h : R a = a) :
    ((Omega.mk (R := R) a h : R.Omega) : α) = a := rfl

@[simp] lemma apply_coe (a : R.Omega) : R (a : α) = a := by
  obtain ⟨x, hx⟩ := a.property
  have hx₁ : R (a : α) = R (R x) := congrArg R hx.symm
  have hx₂ : R (R x) = R x := R.idempotent x
  exact hx₁.trans (hx₂.trans hx)

@[simp] lemma apply_mk (a : α) (h : R a = a) :
    R ((Omega.mk (R := R) a h : R.Omega) : α) = Omega.mk (R := R) a h := by
  simpa using (apply_coe (R := R) (a := Omega.mk (R := R) a h))

end Omega

/-- The primordial fixed point as an inhabitant of `Ω_R`. -/
def process (R : Reentry α) : R.Omega :=
  Omega.mk (R := R) R.primordial R.primordial_mem

/-- The complementary fixed point capturing the counter-process. -/
def counterProcess (R : Reentry α) : R.Omega :=
  Omega.mk (R := R) R.counter R.counter_mem

@[simp] lemma process_coe (R : Reentry α) :
    ((R.process : R.Omega) : α) = R.primordial := rfl

@[simp] lemma counterProcess_coe (R : Reentry α) :
    ((R.counterProcess : R.Omega) : α) = R.counter := rfl

/-- Process and counter-process are disjoint fixed points in `Ω_R`. -/
lemma process_inf_counter (R : Reentry α) :
    R.process ⊓ R.counterProcess = ⊥ := by
  have h_le : R.process ⊓ R.counterProcess ≤ ⊥ := by
    change ((R.process ⊓ R.counterProcess : R.Omega) : α)
        ≤ ((⊥ : R.Omega) : α)
    simp [process, counterProcess, R.orthogonal]
  exact le_antisymm h_le bot_le

/-- The primordial fixed point lies strictly above the boundary. -/
lemma process_pos (R : Reentry α) : ⊥ < ((R.process : R.Omega) : α) := by
  change ⊥ < R.primordial
  exact R.primordial_nonbot

/-- The primordial process lies inside the designated support window. -/
lemma process_in_support (R : Reentry α) :
    ((R.process : R.Omega) : α) ≤ R.support := by
  -- This is just the `primordial_in_support` field transported to `Ω_R`.
  simpa [process_coe] using R.primordial_in_support

/-- The counter-process fixed point lies strictly above the boundary. -/
lemma counter_pos (R : Reentry α) : ⊥ < ((R.counterProcess : R.Omega) : α) := by
  change ⊥ < R.counter
  exact R.counter_nonbot

/-- Package the complementary fixed points generated by re-entry. -/
def complementaryPair (R : Reentry α) : R.Omega × R.Omega :=
  ⟨R.process, R.counterProcess⟩

@[simp] lemma complementaryPair_fst (R : Reentry α) :
    (R.complementaryPair.fst : α) = R.primordial := rfl

@[simp] lemma complementaryPair_snd (R : Reentry α) :
    (R.complementaryPair.snd : α) = R.counter := rfl

@[simp] lemma complementaryPair_inf (R : Reentry α) :
    R.complementaryPair.fst ⊓ R.complementaryPair.snd = ⊥ :=
  R.process_inf_counter

/-- Candidates for the Euler boundary: fixed points strictly above the boundary element and
    lying inside the designated support window. -/
def boundaryCandidates (R : Reentry α) : Set (R.Omega) :=
  {x | ⊥ < (x : α) ∧ (x : α) ≤ R.support}

@[simp] lemma mem_boundaryCandidates (R : Reentry α) (x : R.Omega) :
    x ∈ R.boundaryCandidates ↔
      ⊥ < (x : α) ∧ (x : α) ≤ R.support := Iff.rfl

/-- The primordial fixed point is a boundary candidate. -/
lemma process_mem_boundaryCandidates (R : Reentry α) :
    R.process ∈ R.boundaryCandidates := by
  constructor
  · -- positivity
    simpa [process_coe, boundaryCandidates] using R.process_pos
  · -- support membership
    -- `R.process` is built from `R.primordial`, which lies inside `support`.
    change (R.primordial : α) ≤ R.support
    exact R.primordial_in_support

/-- The Euler boundary is the infimum of all nontrivial fixed points. -/
noncomputable def eulerBoundary (R : Reentry α) : R.Omega :=
  sInf (R.boundaryCandidates)

lemma eulerBoundary_def (R : Reentry α) :
    R.eulerBoundary = sInf (R.boundaryCandidates) := rfl

/-- Any boundary candidate dominates the Euler boundary. -/
lemma eulerBoundary_le_of_candidate (R : Reentry α) {x : R.Omega}
    (hx : x ∈ R.boundaryCandidates) : R.eulerBoundary ≤ x := by
  simpa [eulerBoundary_def] using sInf_le (a := x) hx

/-- A lower bound of boundary candidates lies below the Euler boundary. -/
lemma le_of_lower_bound (R : Reentry α) {a : R.Omega}
    (h : ∀ ⦃x⦄, x ∈ R.boundaryCandidates → a ≤ x) :
    a ≤ R.eulerBoundary := by
  classical
  refine le_sInf ?_
  intro x hx
  exact h hx

/-- The Euler boundary lies beneath the primordial process. -/
lemma eulerBoundary_le_process (R : Reentry α) :
    R.eulerBoundary ≤ R.process :=
  eulerBoundary_le_of_candidate (R := R) (x := R.process)
    (R.process_mem_boundaryCandidates)

/-- The primordial process dominates any boundary candidate in the core. -/
lemma process_le_of_candidate (R : Reentry α) {x : R.Omega}
    (hx : x ∈ R.boundaryCandidates) :
    R.process ≤ x := by
  -- Unpack the candidate conditions.
  rcases hx with ⟨hx_pos, hx_sup⟩
  -- Work on the ambient carrier.
  change (R.primordial : α) ≤ (x : α)
  have hx_fix := Omega.apply_coe (R := R) (a := x)
  exact R.primordial_minimal hx_fix hx_pos hx_sup

/-- The primordial process also bounds the Euler boundary from below. -/
lemma process_le_eulerBoundary (R : Reentry α) :
    R.process ≤ R.eulerBoundary := by
  refine R.le_of_lower_bound ?_
  intro x hx
  exact process_le_of_candidate (R := R) hx

@[simp] lemma eulerBoundary_eq_process (R : Reentry α) :
    R.eulerBoundary = R.process :=
  le_antisymm (R.eulerBoundary_le_process) (R.process_le_eulerBoundary)

/-- In the ambient primary algebra, the carrier of the Euler boundary
coincides with the primordial fixed point. -/
@[simp] lemma eulerBoundary_coe (R : Reentry α) :
    ((R.eulerBoundary : R.Omega) : α) = R.primordial := by
  simp [eulerBoundary_eq_process, process_coe]

/-- The Euler boundary is itself positive in the ambient algebra. -/
lemma eulerBoundary_pos (R : Reentry α) :
    ⊥ < ((R.eulerBoundary : R.Omega) : α) := by
  simpa [eulerBoundary_eq_process] using (process_pos (R := R))

/-- Consequently, the Euler boundary belongs to the candidate set. -/
lemma eulerBoundary_mem_candidates (R : Reentry α) :
    R.eulerBoundary ∈ R.boundaryCandidates := by
  -- Positivity and support membership for `eulerBoundary` follow from the
  -- corresponding properties of `process` together with
  -- `eulerBoundary_le_process`.
  have hpos : ⊥ < ((R.eulerBoundary : R.Omega) : α) :=
    R.eulerBoundary_pos
  have hproc_sup :
      ((R.process : R.Omega) : α) ≤ R.support := by
    simpa [process_coe] using R.primordial_in_support
  have hle : (R.eulerBoundary : R.Omega) ≤ R.process :=
    R.eulerBoundary_le_process
  have hsup :
      ((R.eulerBoundary : R.Omega) : α) ≤ R.support :=
    le_trans (by
      -- Coerce the Ω-inequality to the ambient carrier.
      exact hle) hproc_sup
  exact And.intro hpos hsup

/-- The Euler boundary is the least element of the boundary candidates
with respect to the Ω-order: it belongs to the candidate set and lies
below every other candidate. -/
lemma eulerBoundary_isLeast (R : Reentry α) :
    IsLeast (R.boundaryCandidates) (R.eulerBoundary) := by
  refine ⟨R.eulerBoundary_mem_candidates, ?_⟩
  intro x hx
  exact R.eulerBoundary_le_of_candidate hx

/-- The Euler boundary lies inside the designated support window. -/
lemma eulerBoundary_in_support (R : Reentry α) :
    ((R.eulerBoundary : R.Omega) : α) ≤ R.support := by
  -- Unpack the support component from membership in `boundaryCandidates`.
  have h :=
    (R.mem_boundaryCandidates (x := R.eulerBoundary)).1
      (R.eulerBoundary_mem_candidates)
  exact h.2

/-- Minimality of the Euler boundary among nontrivial fixed points in the
support window.  In the ambient carrier it is strictly positive, is a fixed
point of the nucleus, and lies below every other nontrivial fixed point whose
carrier lies inside `support`. -/
lemma eulerBoundary_minimal_nontrivial (R : Reentry α) :
    ⊥ < ((R.eulerBoundary : R.Omega) : α) ∧
    R (((R.eulerBoundary : R.Omega) : α)) =
      ((R.eulerBoundary : R.Omega) : α) ∧
    ∀ {y : R.Omega},
      ⊥ < (y : α) → (y : α) ≤ R.support →
        ((R.eulerBoundary : R.Omega) : α) ≤ (y : α) := by
  constructor
  · -- Positivity follows from the generic process lemma.
    exact R.eulerBoundary_pos
  constructor
  · -- `eulerBoundary` is an Ω-fixed-point, hence a fixed point of `R`.
    simp
  · intro y hy_pos hy_sup
    -- Apply primordial minimality to the ambient carrier of `y`.
    have hy_fix : R ((y : R.Omega) : α) = (y : α) :=
      Omega.apply_coe (R := R) (a := y)
    have hprim_le_y : R.primordial ≤ (y : α) :=
      R.primordial_minimal hy_fix hy_pos hy_sup
    -- Rewrite the left-hand side in terms of the Euler boundary.
    change ((R.eulerBoundary : R.Omega) : α) ≤ (y : α)
    simpa [eulerBoundary_eq_process, process_coe] using hprim_le_y

/-- The Euler boundary also lies below the counter-process fixed point whenever the latter
    lies inside the support window. -/
lemma eulerBoundary_le_counter (R : Reentry α)
    (hcounter_sup : (R.counter : α) ≤ R.support) :
    R.eulerBoundary ≤ R.counterProcess := by
  -- First show that the counter-process is itself a boundary candidate.
  have hcand : R.counterProcess ∈ R.boundaryCandidates := by
    constructor
    · -- positivity
      simpa [boundaryCandidates, counterProcess_coe] using R.counter_pos
    · -- support membership
      simpa [counterProcess_coe] using hcounter_sup
  -- Then apply the generic Euler-boundary lower-bound lemma.
  exact eulerBoundary_le_of_candidate (R := R) (x := R.counterProcess) hcand

@[simp] lemma complementaryPair_fst_euler (R : Reentry α) :
    R.complementaryPair.fst = R.eulerBoundary := by
  ext
  simp [complementaryPair, process, eulerBoundary_eq_process]

/-- The Euler boundary and counter-process meet only at bottom. -/
lemma eulerBoundary_complementary (R : Reentry α) :
    R.eulerBoundary ⊓ R.counterProcess = ⊥ := by
  calc
    R.eulerBoundary ⊓ R.counterProcess
        = R.process ⊓ R.counterProcess := by
          simp [eulerBoundary_eq_process]
    _ = ⊥ := R.process_inf_counter

/-- Uniqueness of the Euler boundary as the minimal nontrivial fixed point in
the support window: any Ω-element that is strictly above `⊥`, lies in
`support`, and is pointwise ≤ every other positive Ω-element must in fact
coincide with the Euler boundary. -/
lemma eulerBoundary_unique_minimal (R : Reentry α) (x : R.Omega)
    (hx_nontrivial : ⊥ < (x : α))
    (hx_support : (x : α) ≤ R.support)
    (hx_min : ∀ y : R.Omega, ⊥ < (y : α) → (x : α) ≤ (y : α)) :
    x = R.eulerBoundary := by
  -- `x ≤ process` follows from minimality with respect to the primordial
  -- process, which is itself positive.
  have hproc_pos : ⊥ < ((R.process : R.Omega) : α) :=
    R.process_pos
  have hx_le_process : x ≤ R.process := by
    change (x : α) ≤ ((R.process : R.Omega) : α)
    exact hx_min _ hproc_pos
  -- `process ≤ x` follows from primordial minimality applied to the carrier of
  -- `x` inside the support window.
  have hx_fix : R ((x : R.Omega) : α) = (x : α) :=
    Omega.apply_coe (R := R) (a := x)
  have hprim_le_x : R.primordial ≤ (x : α) :=
    R.primordial_minimal hx_fix hx_nontrivial hx_support
  have hprocess_le_x : R.process ≤ x := by
    change ((R.process : R.Omega) : α) ≤ (x : α)
    simpa [process_coe] using hprim_le_x
  -- Conclude equality in `Ω_R`, then rewrite via `eulerBoundary_eq_process`.
  have hx_eq_process : x = R.process :=
    le_antisymm hx_le_process hprocess_le_x
  simpa [eulerBoundary_eq_process] using hx_eq_process

/-- Support-aware variant of `eulerBoundary_unique_minimal`: it is enough to
assume minimality of `x` only with respect to positive fixed points that lie
inside the designated support window. -/
lemma eulerBoundary_unique_minimal_support (R : Reentry α) (x : R.Omega)
    (hx_nontrivial : ⊥ < (x : α))
    (hx_support : (x : α) ≤ R.support)
    (hx_min :
      ∀ y : R.Omega, ⊥ < (y : α) → (y : α) ≤ R.support →
        (x : α) ≤ (y : α)) :
    x = R.eulerBoundary := by
  -- As in `eulerBoundary_unique_minimal`, it suffices to compare `x` with the
  -- primordial process, which is itself positive and lies in `support`.
  have hproc_pos : ⊥ < ((R.process : R.Omega) : α) := R.process_pos
  have hproc_sup : ((R.process : R.Omega) : α) ≤ R.support := by
    simpa [process_coe] using R.primordial_in_support
  have hx_le_process : x ≤ R.process := by
    change (x : α) ≤ ((R.process : R.Omega) : α)
    exact hx_min _ hproc_pos hproc_sup
  -- The converse inequality uses `primordial_minimal` as before.
  have hx_fix : R ((x : R.Omega) : α) = (x : α) :=
    Omega.apply_coe (R := R) (a := x)
  have hprim_le_x : R.primordial ≤ (x : α) :=
    R.primordial_minimal hx_fix hx_nontrivial hx_support
  have hprocess_le_x : R.process ≤ x := by
    change ((R.process : R.Omega) : α) ≤ (x : α)
    simpa [process_coe] using hprim_le_x
  have hx_eq_process : x = R.process :=
    le_antisymm hx_le_process hprocess_le_x
  simpa [eulerBoundary_eq_process] using hx_eq_process

end Reentry

end LoF
end HeytingLean
