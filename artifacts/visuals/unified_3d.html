<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Unified System â€” 3D Proof Map</title>
  <style>
    :root { color-scheme: dark; }
    body { margin: 0; overflow: hidden; background: #0b0f14; color: #e6eef7; font: 13px/1.35 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #ui { position: fixed; top: 12px; left: 12px; right: 12px; display: flex; gap: 10px; align-items: center; z-index: 10; flex-wrap: wrap; }
    .panel { background: rgba(15,23,33,0.92); border: 1px solid #1c2a3a; border-radius: 10px; padding: 10px 12px; backdrop-filter: blur(6px); }
    input[type="text"]{ width: 280px; max-width: 40vw; background:#0b1320; color:#e6eef7; border:1px solid #24364a; border-radius: 8px; padding: 7px 10px; outline:none; }
    label { user-select:none; }
    button { background:#132033; color:#e6eef7; border:1px solid #24364a; border-radius: 8px; padding: 7px 10px; cursor:pointer; }
    button:hover { background:#182a42; }
    #tip { position: fixed; pointer-events:none; z-index: 20; padding: 6px 8px; border-radius: 8px; background: rgba(0,0,0,0.75); border:1px solid rgba(255,255,255,0.10); display:none; max-width: 56vw; }
    #details { position: fixed; right: 12px; bottom: 12px; width: min(480px, calc(100vw - 24px)); max-height: 40vh; overflow:auto; white-space: pre-wrap; }
    #details h3 { margin: 0 0 8px; font-size: 14px; }
    .muted { color:#b8c7d9; }
    .row { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
    a { color:#8ab4f8; text-decoration:none; }
    a:hover{ text-decoration:underline; }
    code { background:#0b1320; border:1px solid #24364a; border-radius: 6px; padding:1px 6px; }
    #container { width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <div id="ui" class="row">
    <div class="panel row">
      <a href="./index.html">&larr; index</a>
      <input id="q" type="text" placeholder="Search declarations..." />
      <label><input id="showEdges" type="checkbox" checked /> edges</label>
      <button id="reset">Reset</button>
    </div>
    <div class="panel muted">Rotate: drag &middot; Zoom: wheel &middot; Click to select</div>
  </div>
  <div id="tip"></div>
  <div id="details" class="panel" style="display:none"></div>
  <div id="container"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="./unified_proofs_data.js"></script>
  <script>
    ;(() => {
      const data = window.UNIFIED_PROOFS || { items: [], edges: [] }
      const items = data.items || []
      const edges = data.edges || []

      const colorForFamily = (fam) => {
        const map = {
          'LoF': 0x6c5ce7,
          'LoFKernel': 0xa29bfe,
          'Combinator': 0xfd79a8,
          'Topos': 0xf39c12,
          'TensorLogic': 0x00b894,
          'Bridge': 0xe17055,
          'CLI': 0x0984e3,
          'Test': 0x636e72
        }
        return map[fam] || 0x90a4ae
      }

      const container = document.getElementById('container')
      const tip = document.getElementById('tip')
      const details = document.getElementById('details')
      const q = document.getElementById('q')
      const showEdgesEl = document.getElementById('showEdges')
      const resetBtn = document.getElementById('reset')

      const scene = new THREE.Scene()
      scene.background = new THREE.Color(0x0b0f14)

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000)
      camera.position.set(2, 2, 2)
      camera.lookAt(0.5, 0.5, 0.5)

      const renderer = new THREE.WebGLRenderer({ antialias: true })
      renderer.setSize(window.innerWidth, window.innerHeight)
      container.appendChild(renderer.domElement)

      // Nodes
      const spheres = []
      const geometry = new THREE.SphereGeometry(0.015, 16, 16)

      for (let i = 0; i < items.length; i++) {
        const it = items[i]
        const pos3 = it.pos3 || { x: 0.5, y: 0.5, z: 0.5 }
        const material = new THREE.MeshBasicMaterial({ color: colorForFamily(it.family) })
        const sphere = new THREE.Mesh(geometry, material)
        sphere.position.set(pos3.x, pos3.y, pos3.z)
        sphere.userData = { index: i }
        scene.add(sphere)
        spheres.push(sphere)
      }

      // Edges
      const edgeMaterial = new THREE.LineBasicMaterial({ color: 0xcfd8dc, opacity: 0.35, transparent: true })
      const edgeLines = []

      for (const [i, j] of edges) {
        const a = items[i].pos3 || { x: 0.5, y: 0.5, z: 0.5 }
        const b = items[j].pos3 || { x: 0.5, y: 0.5, z: 0.5 }
        const pts = [new THREE.Vector3(a.x, a.y, a.z), new THREE.Vector3(b.x, b.y, b.z)]
        const lineGeo = new THREE.BufferGeometry().setFromPoints(pts)
        const line = new THREE.Line(lineGeo, edgeMaterial)
        scene.add(line)
        edgeLines.push(line)
      }

      // Controls
      let isDragging = false
      let prevX = 0, prevY = 0
      let theta = Math.PI / 4, phi = Math.PI / 4, radius = 2.5

      const updateCamera = () => {
        camera.position.x = 0.5 + radius * Math.sin(phi) * Math.cos(theta)
        camera.position.y = 0.5 + radius * Math.cos(phi)
        camera.position.z = 0.5 + radius * Math.sin(phi) * Math.sin(theta)
        camera.lookAt(0.5, 0.5, 0.5)
      }
      updateCamera()

      renderer.domElement.addEventListener('mousedown', (e) => {
        isDragging = true
        prevX = e.clientX
        prevY = e.clientY
      })

      window.addEventListener('mouseup', () => { isDragging = false })

      window.addEventListener('mousemove', (e) => {
        if (isDragging) {
          const dx = e.clientX - prevX
          const dy = e.clientY - prevY
          theta += dx * 0.01
          phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi - dy * 0.01))
          prevX = e.clientX
          prevY = e.clientY
          updateCamera()
        }
      })

      renderer.domElement.addEventListener('wheel', (e) => {
        e.preventDefault()
        radius = Math.max(0.5, Math.min(10, radius + e.deltaY * 0.002))
        updateCamera()
      }, { passive: false })

      resetBtn.addEventListener('click', () => {
        theta = Math.PI / 4
        phi = Math.PI / 4
        radius = 2.5
        updateCamera()
      })

      showEdgesEl.addEventListener('change', () => {
        for (const line of edgeLines) {
          line.visible = showEdgesEl.checked
        }
      })

      // Raycaster for selection
      const raycaster = new THREE.Raycaster()
      const mouse = new THREE.Vector2()
      let selected = null

      renderer.domElement.addEventListener('click', (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1
        raycaster.setFromCamera(mouse, camera)
        const intersects = raycaster.intersectObjects(spheres)
        if (intersects.length > 0) {
          const idx = intersects[0].object.userData.index
          selected = idx
          showDetails(items[idx])
        } else {
          selected = null
          details.style.display = 'none'
        }
      })

      const escapeHtml = (s) => String(s).replace(/[&<>\"]/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;'}[c]||c))

      const showDetails = (it) => {
        const loc = it.path ? `${it.path}:${it.line||1}` : ''
        details.style.display = 'block'
        details.innerHTML =
          `<h3>${escapeHtml(it.name||'')}</h3>` +
          `<div class="muted">${escapeHtml(it.kind||'')} &middot; <code>${escapeHtml(it.family||'')}</code></div>` +
          (loc ? `<div style="margin-top:6px"><code>${escapeHtml(loc)}</code></div>` : '') +
          (it.snippet ? `<div style="margin-top:10px" class="muted">${escapeHtml(it.snippet)}</div>` : '')
      }

      // Filter
      let query = ''
      q.addEventListener('input', () => {
        query = q.value.toLowerCase()
        for (let i = 0; i < items.length; i++) {
          const match = !query || items[i].name.toLowerCase().includes(query)
          spheres[i].visible = match
        }
        // Update edge visibility
        for (let k = 0; k < edges.length; k++) {
          const [i, j] = edges[k]
          edgeLines[k].visible = showEdgesEl.checked && spheres[i].visible && spheres[j].visible
        }
      })

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()
        renderer.setSize(window.innerWidth, window.innerHeight)
      })

      const animate = () => {
        requestAnimationFrame(animate)
        renderer.render(scene, camera)
      }
      animate()
    })()
  </script>
</body>
</html>
