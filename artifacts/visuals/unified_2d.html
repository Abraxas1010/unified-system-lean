<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Unified System â€” 2D Proof Map</title>
    <style>
      :root { color-scheme: dark; }
      body { margin: 0; overflow: hidden; background:#0b0f14; color:#e6eef7; font: 13px/1.35 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
      #ui { position: fixed; top: 12px; left: 12px; right: 12px; display:flex; gap: 10px; align-items: center; z-index: 10; }
      .panel { background: rgba(15,23,33,0.92); border: 1px solid #1c2a3a; border-radius: 10px; padding: 10px 12px; backdrop-filter: blur(6px); }
      input[type="text"]{ width: 360px; max-width: 60vw; background:#0b1320; color:#e6eef7; border:1px solid #24364a; border-radius: 8px; padding: 7px 10px; outline:none; }
      label { user-select:none; }
      button { background:#132033; color:#e6eef7; border:1px solid #24364a; border-radius: 8px; padding: 7px 10px; cursor:pointer; }
      button:hover { background:#182a42; }
      #tip { position: fixed; pointer-events:none; z-index: 20; padding: 6px 8px; border-radius: 8px; background: rgba(0,0,0,0.75); border:1px solid rgba(255,255,255,0.10); display:none; max-width: 56vw; }
      #details { position: fixed; right: 12px; bottom: 12px; width: min(520px, calc(100vw - 24px)); max-height: 45vh; overflow:auto; white-space: pre-wrap; }
      #details h3 { margin: 0 0 8px; font-size: 14px; }
      .muted { color:#b8c7d9; }
      .row { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
      canvas { display:block; }
      a { color:#8ab4f8; text-decoration:none; }
      a:hover{ text-decoration:underline; }
      code { background:#0b1320; border:1px solid #24364a; border-radius: 6px; padding:1px 6px; }
    </style>
  </head>
  <body>
    <div id="ui" class="row">
      <div class="panel row">
        <a href="./index.html">&larr; index</a>
        <input id="q" type="text" placeholder="Search declarations (substring)..." />
        <label><input id="showEdges" type="checkbox" checked /> edges</label>
        <button id="fit">Fit</button>
      </div>
      <div class="panel muted">Pan: drag &middot; Zoom: wheel &middot; Select: click</div>
    </div>
    <div id="tip"></div>
    <div id="details" class="panel" style="display:none"></div>
    <canvas id="c"></canvas>

    <script src="./unified_proofs_data.js"></script>
    <script>
      ;(() => {
        const data = window.UNIFIED_PROOFS || { items: [], edges: [] }
        const items = data.items || []
        const edges = data.edges || []
        const canvas = document.getElementById('c')
        const ctx = canvas.getContext('2d')
        const tip = document.getElementById('tip')
        const details = document.getElementById('details')
        const q = document.getElementById('q')
        const showEdges = document.getElementById('showEdges')
        const fitBtn = document.getElementById('fit')

        const colorForFamily = (fam) => {
          const map = {
            'LoF':'#6c5ce7',
            'LoFKernel':'#a29bfe',
            'Combinator':'#fd79a8',
            'Topos':'#f39c12',
            'TensorLogic':'#00b894',
            'Bridge':'#e17055',
            'CLI':'#0984e3',
            'Test':'#636e72'
          }
          return map[fam] || '#90a4ae'
        }

        const margin = 24
        const view = { s: 1.0, ox: 0, oy: 0 }
        let dragging = null
        let hover = null
        let selected = null
        let query = ''

        const visibleIdx = () => {
          const ql = query.trim().toLowerCase()
          const idx = []
          for (let i=0;i<items.length;i++){
            const it = items[i]
            if (!it) continue
            if (!ql || String(it.name||'').toLowerCase().includes(ql)) idx.push(i)
          }
          return idx
        }
        let vis = visibleIdx()

        const resize = () => {
          canvas.width = window.innerWidth
          canvas.height = window.innerHeight
          render()
        }

        const toX = (px) => margin + px * (canvas.width - 2*margin) * view.s + view.ox
        const toY = (py) => margin + (1 - py) * (canvas.height - 2*margin) * view.s + view.oy
        const fromX = (sx) => (sx - margin - view.ox) / ((canvas.width - 2*margin) * view.s)
        const fromY = (sy) => 1 - (sy - margin - view.oy) / ((canvas.height - 2*margin) * view.s)

        const fit = () => {
          vis = visibleIdx()
          if (!vis.length) return
          let minX=1e9,maxX=-1e9,minY=1e9,maxY=-1e9
          for (const i of vis){
            const p = items[i].pos || {x:0.5,y:0.5}
            minX = Math.min(minX, p.x); maxX=Math.max(maxX,p.x)
            minY = Math.min(minY, p.y); maxY=Math.max(maxY,p.y)
          }
          const pad = 0.10
          const w = Math.max(0.02, (maxX-minX)*(1+pad))
          const h = Math.max(0.02, (maxY-minY)*(1+pad))
          view.s = Math.max(0.3, Math.min(10, Math.min(1/w, 1/h)))
          const cx=(minX+maxX)/2, cy=(minY+maxY)/2
          const targetX = canvas.width/2
          const targetY = canvas.height/2
          const innerW = canvas.width - 2*margin
          const innerH = canvas.height - 2*margin
          view.ox = targetX - (margin + cx * innerW * view.s)
          view.oy = targetY - (margin + (1-cy) * innerH * view.s)
          render()
        }
        fitBtn.addEventListener('click', fit)

        const dist2 = (a,b,c,d) => (a-c)*(a-c)+(b-d)*(b-d)
        const hitTest = (sx, sy) => {
          let best = null
          let bestD = Infinity
          for (const i of vis){
            const p = items[i].pos
            if (!p) continue
            const x = toX(p.x), y = toY(p.y)
            const d = dist2(sx, sy, x, y)
            if (d < bestD) { bestD = d; best = i }
          }
          const r = 12
          if (best !== null && bestD <= r*r) return best
          return null
        }

        const showTip = (sx, sy, it) => {
          tip.style.display = 'block'
          tip.style.left = (sx + 12) + 'px'
          tip.style.top = (sy + 12) + 'px'
          tip.textContent = it.name
        }
        const hideTip = () => { tip.style.display='none' }

        const showDetails = (it) => {
          const loc = it.path ? `${it.path}:${it.line||1}` : ''
          details.style.display = 'block'
          details.innerHTML =
            `<h3>${escapeHtml(it.name||'')}</h3>` +
            `<div class="muted">${escapeHtml(it.kind||'')} &middot; <code>${escapeHtml(it.family||'')}</code></div>` +
            (loc ? `<div style="margin-top:6px"><code>${escapeHtml(loc)}</code></div>` : '') +
            (it.snippet ? `<div style="margin-top:10px" class="muted">${escapeHtml(it.snippet)}</div>` : '')
        }

        const escapeHtml = (s) => String(s).replace(/[&<>\"]/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;'}[c]||c))

        const render = () => {
          vis = visibleIdx()
          ctx.clearRect(0,0,canvas.width,canvas.height)
          ctx.fillStyle = '#0b0f14'
          ctx.fillRect(0,0,canvas.width,canvas.height)

          // edges
          if (showEdges.checked) {
            ctx.lineWidth = 1
            ctx.strokeStyle = 'rgba(207,216,220,0.35)'
            ctx.beginPath()
            const visSet = new Set(vis)
            for (const [i,j] of edges){
              if (!visSet.has(i) || !visSet.has(j)) continue
              const a = items[i].pos, b = items[j].pos
              if (!a || !b) continue
              ctx.moveTo(toX(a.x), toY(a.y))
              ctx.lineTo(toX(b.x), toY(b.y))
            }
            ctx.stroke()
          }

          // nodes
          for (const i of vis){
            const it = items[i]
            const p = it.pos
            if (!p) continue
            const x = toX(p.x), y = toY(p.y)
            const base = 3.4
            const r = (i === selected ? base*1.9 : i === hover ? base*1.5 : base)
            ctx.beginPath()
            ctx.fillStyle = colorForFamily(it.family || '')
            ctx.globalAlpha = 0.95
            ctx.arc(x, y, r, 0, Math.PI*2)
            ctx.fill()
            if (i === selected) {
              ctx.globalAlpha = 1
              ctx.strokeStyle = '#ffffff'
              ctx.lineWidth = 1.2
              ctx.stroke()
            }
          }
          ctx.globalAlpha = 1
        }

        canvas.addEventListener('mousedown', (ev) => {
          dragging = { x: ev.clientX, y: ev.clientY, ox: view.ox, oy: view.oy }
        })
        window.addEventListener('mouseup', () => { dragging = null })
        window.addEventListener('mousemove', (ev) => {
          if (dragging) {
            view.ox = dragging.ox + (ev.clientX - dragging.x)
            view.oy = dragging.oy + (ev.clientY - dragging.y)
            render()
            return
          }
          const h = hitTest(ev.clientX, ev.clientY)
          hover = h
          if (hover !== null) showTip(ev.clientX, ev.clientY, items[hover])
          else hideTip()
          render()
        })
        canvas.addEventListener('click', (ev) => {
          const h = hitTest(ev.clientX, ev.clientY)
          selected = h
          if (selected !== null) showDetails(items[selected])
          else details.style.display='none'
          render()
        })
        canvas.addEventListener('wheel', (ev) => {
          ev.preventDefault()
          const s0 = view.s
          const delta = Math.sign(ev.deltaY)
          const factor = delta > 0 ? 0.90 : 1.11
          view.s = Math.max(0.15, Math.min(25, view.s * factor))
          const px = fromX(ev.clientX), py = fromY(ev.clientY)
          const innerW = (canvas.width - 2*margin)
          const innerH = (canvas.height - 2*margin)
          view.ox = ev.clientX - (margin + px * innerW * view.s)
          view.oy = ev.clientY - (margin + (1-py) * innerH * view.s)
          if (Math.abs(view.s - s0) < 1e-6) return
          render()
        }, { passive:false })

        q.addEventListener('input', () => { query = q.value; fit() })

        window.addEventListener('resize', resize)
        resize()
        fit()
      })()
    </script>
  </body>
</html>
